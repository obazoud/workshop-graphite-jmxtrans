<h2>
<a name="lapplication-cocktail-" class="anchor" href="#lapplication-cocktail-"><span class="octicon octicon-link"></span></a>L'application Cocktail :</h2>	

<p>Ouvrez votre <a href="#">web app Graphite</a>. C'est dans cette interface que vous pourrez admirer les magnifiques graphes que vous allez bientôt commencer à alimenter.</p>

<p>Connectez-vous en SSH à l'adresse de votre Tomcat</p>

{% highlight bash %}
$ ssh ec2-user@{{page.group}}-cocktail-monitoring.aws.xebiatechevent.info
{% endhighlight %}

<p>Récupérer l'application <a href="https://github.com/antoinemichaud/embedded-jmxtrans-samples">Cocktail</a></p>

{% highlight bash %}
$ git clone https://github.com/antoinemichaud/embedded-jmxtrans-samples.git
{% endhighlight %}

<p>Placez-vous dans le répertoire embedded-jmxtrans-samples/embedded-jmxtrans-webapp-coktail</p>

<p>Packagez et démarrez l'application : </p>

{% highlight bash %}
$ cd embedded-jmxtrans-samples/embedded-jmxtrans-webapp-coktail
$ mvn clean package jetty:run
{% endhighlight %}

<p>Une fois l'application terminée de démarrer, rendez-vous sur le port 8080 de votre toute nouvelle application</p>

<p>Et pour nous récompenser de cette dure labeur achetons-nous 1 sex on the beach.

<h2>Configuration de JMXTrans</h2>

<p>Actuellement, il n'existe pas de moyen simple d'observer les données système, de la JVM, ainsi que le comportement de l'utilisateur sur l'application.</p>
<p>Pour envoyer des données à Graphite, nous allons envoyer des données grâce à JMXTrans.</p>
<p>
  Pour nous éviter l'installation d'un serveur JMXTrans, nous allons utiliser JMXTrans Embedded.</p>
  <ul>
    <li>Inclure le plugin maven de JMXTrans dans les sources de l'application Cocktail (utiliser VIM pour éditer le POM par exemple);</li>
    
{% highlight xml %}
<dependency>
    <groupId>org.jmxtrans.embedded</groupId>
    <artifactId>embedded-jmxtrans</artifactId>
    <version>1.0.9-SNAPSHOT</version>
</dependency>
{% endhighlight %}

  </ul>
  <p>Une fois la dépendance résolue, il faut configurer notre serveur JMXTrans embedded. JMXTrans embedded utilise un fichier JSON pour sa configuration.</p>
  <ul>
    <li>Dans le répertoire src/main/resources, créer un fichier jmxtrans.json</li>  
  </ul>

{% highlight bash %}
$ touch src/main/resources/jmxtrans.json
{% endhighlight %}
  <ul>
    <li>Pour commencer, on va faire pointer notre jmxtrans vers le serveur graphite et logger les données que nous envoyons à graphite avec SLF4J.</li>
  </ul>
{% highlight json %}
{
    "outputWriters": [
        {
            "@class": "org.jmxtrans.embedded.output.Slf4jWriter",
            "settings": {
                "enabled": "${jmxtrans.writer.slf4j.enabled:true}"
            }
        },
        {
            "@class": "org.jmxtrans.embedded.output.GraphiteWriter",
            "settings": {
                "host": "{{page.group}}-graphite-monitoring.aws.xebiatechevent.info",
                "port": "2003",
                "enabled": "true",
                "namePrefix": "demo"
            }
        }
    ]
}
{% endhighlight %}

  C'est Spring MVC qui va se charger d'aller chercher le fichier de configuration de jmxtrans
  <ul>
    <li>Ouvrir le fichier src/main/webapp/WEB-INF/spring-mvc-servlet.xml</li>
    <li>Insérer les lignes suivantes :</li>
  </ul>
  
{% highlight xml %}
<beans ...
       xmlns:jmxtrans="http://www.jmxtrans.org/schema/embedded"
       xsi:schemaLocation="... http://www.jmxtrans.org/schema/embedded http://www.jmxtrans.org/schema/embedded/jmxtrans.xsd">
		
    <jmxtrans:jmxtrans>
        <jmxtrans:configuration>classpath:jmxtrans.json</jmxtrans:configuration>
        <jmxtrans:configuration>classpath:org/jmxtrans/embedded/config/tomcat-7.json</jmxtrans:configuration>
        <jmxtrans:configuration>classpath:org/jmxtrans/embedded/config/jmxtrans-internals.json</jmxtrans:configuration>
        <jmxtrans:configuration>classpath:org/jmxtrans/embedded/config/jvm-sun-hotspot.json</jmxtrans:configuration>
    </jmxtrans:jmxtrans>
    ...
</beans>
    
{% endhighlight %}

<ul>
  <li>La première ligne concerne la configuration jmxtrans.json que nous venons d'écrire. Elle définit les canaux de sortie de jmxtrans et permettra plus loin dans cet atelier de définir les métriques métier.</li>
  <li>Les trois dernières lignes permettent de définir les métriques du système et de la JVM.</li>
</ul>

<h2>Visualisation des données système sur Graphite :</h2>
  
  <ul>
    <li>Rendez-vous sur l'adresse http://{{page.group}}-graphite-monitoring.aws.xebiatechevent.info</li>
    <li>Dans demo/jvm, vous avez accès à plusieurs métriques de la JVM avec lesquelles vous pouvez commencer à jouer</li>
  </ul>
  
<h2>Ajout de données métier</h2>
<p>Afin de pouvoir prévoir de nouvelles évolutions de notre application, nous allons transmettre à Graphite des données métier.</p>

<p>JMXTrans a l'avantage de permettre la configuration des données à transmettre avec de simples annotations JMX.</p>

<p>Mettre en place un compteur de type "GAUGE" qui donne le nombre de fois que la page d'accueil a été affichée.</p>

<p>Pour cela, vous pouvez suivre les étapes suivantes :</p>

<ul>
  <li>Créer le compteur displayedHomeCount (de préférence de type AtomicInteger pour les problèmes de concurrence)</li>
  <li>Augmenter le compteur à chaque fois qu'un utilisateur envoie une requête GET sur la homepage</li>
  <li>Exposer le contrôleur avec l'annotation @ManagedResource avec pour valeur "cocktail:type=CocktailController,name=CocktailController"</li>
  <li>Créer un getter qui donne le compte et l'annoter avec @ManagedMetric</li>
  <li>Ajouter la configuration suivante au début du fichier jmxtrans.json :</li>
</ul>

{% highlight json %}
"queries": [
        {
            "objectName": "cocktail:type=CocktailController,name=CocktailController",
            "resultAlias": "cocktail",
            "attributes": [
                "DisplayedHomeCount"
            ]
        }
    ],
    
    ...
{% endhighlight %}

<ul>
  <li>Créer les compteur searchedCocktailCount et displayedCocktailCount (de préférence de type AtomicInteger pour les problèmes de concurrence)</li>
  <li>Augmenter le compteur à chaque fois qu'un utilisateur envoie une requête GET vers un cocktail ou cherche un cocktail</li>
  <li>Créer un getter pour chacun qui donne le compte et l'annoter avec @ManagedMetric</li>
  <li>Ajouter les lignes suivantes dans les attributs que nous avons commencé à écrire précédemment :</li>
</ul>

{% highlight json %}
		...

                "DisplayedCocktailCount",
                "SearchedCocktailCount",
                ...
{% endhighlight %}

<ul>
  <li></li>
</ul>

<ul>
  <li></li>
</ul>
  

{% highlight bash %}
$ 
{% endhighlight %}
